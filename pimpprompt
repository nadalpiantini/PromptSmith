#!/bin/bash
# PromptSmith MCP - Escalera de Proceso Inteligente
# Uso: pimpprompt "tu prompt aqu√≠"
# Sistema completamente autom√°tico: detecta contexto, mejora, eval√∫a, guarda como template global
# Zero decisiones manuales, flujo completo integrado

# Colores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Funci√≥n para mostrar ayuda simple
show_help() {
    echo -e "${CYAN}üöÄ pimpprompt - Escalera de Proceso Inteligente${NC}"
    echo ""
    echo -e "${YELLOW}${BOLD}Uso:${NC}"
    echo "  pimpprompt \"tu prompt aqu√≠\""
    echo ""
    echo -e "${YELLOW}${BOLD}Ejemplos:${NC}"
    echo "  pimpprompt \"make sql query for users\""
    echo "  pimpprompt \"create landing page\""
    echo "  pimpprompt \"build mobile app\""
    echo "  pimpprompt \"write authentication system\""
    echo "  pimpprompt \"deploy to cloud\""
    echo ""
    echo -e "${YELLOW}${BOLD}Comandos de b√∫squeda:${NC}"
    echo "  pimpprompt --search \"keyword\"    # Buscar templates existentes"
    echo "  pimpprompt --list                # Listar todos los templates"
    echo "  pimpprompt --list sql            # Listar templates por dominio"
    echo ""
    echo -e "${YELLOW}${BOLD}¬øQu√© hace autom√°ticamente?${NC}"
    echo "  üß† Detecta contexto y dominio autom√°ticamente"
    echo "  üöÄ Mejora tu prompt con optimizaciones inteligentes"
    echo "  üìä Eval√∫a y re-mejora hasta alcanzar 100% de calidad"
    echo "  üíæ Guarda como template global para reutilizar"
    echo "  üîç Busca templates similares existentes"
    echo "  üìà Actualiza estad√≠sticas de uso"
    echo ""
    echo -e "${YELLOW}${BOLD}Dominios que detecta autom√°ticamente:${NC}"
    echo "  ${GREEN}sql${NC}, ${GREEN}web${NC}, ${GREEN}mobile${NC}, ${GREEN}backend${NC}, ${GREEN}frontend${NC}, ${GREEN}ai${NC}, ${GREEN}gaming${NC},"
    echo "  ${GREEN}crypto${NC}, ${GREEN}devops${NC}, ${GREEN}saas${NC}, ${GREEN}branding${NC}, ${GREEN}cine${NC}, ${GREEN}education${NC},"
    echo "  ${GREEN}healthcare${NC}, ${GREEN}finance${NC}, ${GREEN}legal${NC}, ${GREEN}general${NC}"
    echo ""
    echo -e "${PURPLE}üí° Solo escribe tu prompt - el sistema hace todo lo dem√°s autom√°ticamente${NC}"
    echo -e "${PURPLE}   Escalera completa: mejora ‚Üí eval√∫a ‚Üí guarda ‚Üí perfecciona${NC}"
}

# Funci√≥n MEJORADA para detectar dominio con sistema de puntuaci√≥n optimizado
detect_domain() {
    local prompt="$1"
    local current_dir="$(pwd)"
    local prompt_lower=$(echo "$prompt" | tr '[:upper:]' '[:lower:]')
    
    # Initialize scores using parallel arrays approach (compatible with bash 3.2)
    local sql_score=0
    local web_score=0
    local mobile_score=0
    local backend_score=0
    local frontend_score=0
    local ai_score=0
    local gaming_score=0
    local crypto_score=0
    local devops_score=0
    local saas_score=0
    local branding_score=0
    local cine_score=0
    local education_score=0
    local healthcare_score=0
    local finance_score=0
    local legal_score=0
    
    # SQL domain - Strong indicators
    if echo "$prompt_lower" | grep -q -E "(select|insert|update|delete|create table|database|query|sql|postgresql|mysql|schema|join|where)"; then
        sql_score=$((sql_score + 10))
    fi
    
    # Web domain - Enhanced patterns
    if echo "$prompt_lower" | grep -q -E "(website|landing|page|html|css|javascript|react|vue|angular|frontend|ui|ux|responsive|bootstrap|tailwind)"; then
        web_score=$((web_score + 10))
    fi
    # Dashboard and analytics strongly indicate web
    if echo "$prompt_lower" | grep -q -E "(dashboard|analytics|chart|graph|visualization|report|metrics|stats)"; then
        web_score=$((web_score + 8))
    fi
    # Web UI terms
    if echo "$prompt_lower" | grep -q -E "(interface|component|layout|design|user experience|navigation|menu)"; then
        web_score=$((web_score + 6))
    fi
    # "web" should strongly indicate web domain
    if echo "$prompt_lower" | grep -q -E "(web)"; then
        web_score=$((web_score + 12))
    fi
    
    # Mobile domain - Refined patterns (avoid "application" conflicts)
    if echo "$prompt_lower" | grep -q -E "(mobile|ios|android|flutter|react native|swift|kotlin|app store|play store)"; then
        mobile_score=$((mobile_score + 10))
    fi
    # Only count "app" if it's clearly mobile context
    if echo "$prompt_lower" | grep -q -E "(mobile app|ios app|android app|app development|app store)"; then
        mobile_score=$((mobile_score + 8))
    fi
    
    # Backend domain - Enhanced patterns
    if echo "$prompt_lower" | grep -q -E "(api|backend|server|microservice|rest|endpoint|service|middleware|authentication)"; then
        backend_score=$((backend_score + 10))
    fi
    # Enterprise and application context
    if echo "$prompt_lower" | grep -q -E "(enterprise|application|system|architecture|scalable|distributed|load balancer)"; then
        backend_score=$((backend_score + 8))
    fi
    # Infrastructure terms
    if echo "$prompt_lower" | grep -q -E "(infrastructure|cloud|aws|azure|gcp|node\.js|python|java|golang)"; then
        backend_score=$((backend_score + 6))
    fi
    # "database design" should be backend, not SQL
    if echo "$prompt_lower" | grep -q -E "(database design|database architecture|data modeling)"; then
        backend_score=$((backend_score + 12))
    fi
    
    # AI domain - FIXED: More specific patterns to avoid false positives
    if echo "$prompt_lower" | grep -q -E "(machine learning|artificial intelligence|neural network|deep learning|llm|gpt|bert|transformer|pytorch|tensorflow)"; then
        ai_score=$((ai_score + 15))  # Higher priority for core AI terms
    fi
    # Only "training" in AI context, not general training
    if echo "$prompt_lower" | grep -q -E "(model training|ai training|neural training|prediction|classification|regression|dataset|algorithm|nlp|computer vision)"; then
        ai_score=$((ai_score + 8))
    fi
    # FINAL FIX: "machine learning" should ALWAYS be AI, regardless of other patterns
    if echo "$prompt_lower" | grep -q -E "(machine learning|neural network|deep learning)"; then
        ai_score=$((ai_score + 10))  # Extra boost for strong AI terms
    fi
    
    # Gaming domain
    if echo "$prompt_lower" | grep -q -E "(game|gaming|unity|unreal|gameplay|player|level|character|3d|engine|physics)"; then
        gaming_score=$((gaming_score + 10))
    fi
    
    # Crypto domain - Enhanced patterns with context
    if echo "$prompt_lower" | grep -q -E "(blockchain|crypto|bitcoin|ethereum|smart contract|defi|nft|web3|solidity|dapp)"; then
        crypto_score=$((crypto_score + 10))
    fi
    # Distinguish crypto contracts from legal contracts
    if echo "$prompt_lower" | grep -q -E "(smart contract|blockchain contract|ethereum contract|solidity contract)"; then
        crypto_score=$((crypto_score + 8))
        legal_score=$((legal_score - 5)) # Penalize legal for crypto context
    fi
    
    # DevOps domain - Higher priority for devops-specific terms
    if echo "$prompt_lower" | grep -q -E "(deploy|docker|kubernetes|ci/cd|devops|infrastructure|pipeline|helm|terraform)"; then
        devops_score=$((devops_score + 10))
    fi
    # "container" in DevOps context should be strongly devops
    if echo "$prompt_lower" | grep -q -E "(docker container|kubernetes container|container orchestration|container deployment)"; then
        devops_score=$((devops_score + 8))
    fi
    # Generic "container" should still favor devops over ai
    if echo "$prompt_lower" | grep -q -E "container" && echo "$prompt_lower" | grep -q -v -E "(machine learning|artificial intelligence|neural)"; then
        devops_score=$((devops_score + 6))
    fi
    
    # SaaS domain - Lower priority for generic "software"
    if echo "$prompt_lower" | grep -q -E "(saas|subscription|tenant|billing|pricing)"; then
        saas_score=$((saas_score + 10))
    fi
    # "software" should be lower priority unless specifically SaaS
    if echo "$prompt_lower" | grep -q -E "(software platform|software service)" && echo "$prompt_lower" | grep -q -v -E "enterprise"; then
        saas_score=$((saas_score + 6))
    fi
    
    # Branding domain - Higher priority for branding terms
    if echo "$prompt_lower" | grep -q -E "(brand|marketing|copy|messaging|logo|identity|creative|advertising)"; then
        branding_score=$((branding_score + 12))
    fi
    # "campaign" in branding context should be strongly branding
    if echo "$prompt_lower" | grep -q -E "(brand campaign|marketing campaign|ad campaign|advertising campaign)"; then
        branding_score=$((branding_score + 8))
    fi
    # Generic "campaign" should favor branding over AI
    if echo "$prompt_lower" | grep -q -E "campaign" && echo "$prompt_lower" | grep -q -v -E "(machine learning|artificial intelligence|neural)"; then
        branding_score=$((branding_score + 6))
    fi
    
    # Cinema domain
    if echo "$prompt_lower" | grep -q -E "(script|movie|film|screenplay|cinema|director|scene|character|dialogue|story)"; then
        cine_score=$((cine_score + 10))
    fi
    
    # Education domain - FIXED: Only education-specific contexts, not AI contexts
    if echo "$prompt_lower" | grep -q -E "(course|education|tutorial|lesson|curriculum|student|instructor)"; then
        # Don't boost education if it's clearly AI context
        if echo "$prompt_lower" | grep -q -v -E "(machine learning|artificial intelligence|neural|deep learning|model)"; then
            education_score=$((education_score + 12))
        fi
    fi
    # "training course" should be strongly education
    if echo "$prompt_lower" | grep -q -E "(training course|education course|learning course|teach course)"; then
        education_score=$((education_score + 8))
    fi
    # Generic "training" in education context but NOT AI context
    if echo "$prompt_lower" | grep -q -E "training" && echo "$prompt_lower" | grep -q -E "(course|education|teach)" && echo "$prompt_lower" | grep -q -v -E "(machine learning|ai|model|neural)"; then
        education_score=$((education_score + 6))
    fi
    
    # Healthcare domain
    if echo "$prompt_lower" | grep -q -E "(health|medical|medicine|patient|doctor|hospital|clinical|diagnosis|treatment)"; then
        healthcare_score=$((healthcare_score + 10))
    fi
    
    # Finance domain
    if echo "$prompt_lower" | grep -q -E "(finance|banking|money|payment|fintech|investment|trading|portfolio|accounting)"; then
        finance_score=$((finance_score + 10))
    fi
    
    # Legal domain - Only for non-crypto legal contexts
    if echo "$prompt_lower" | grep -q -E "(legal|law|contract|policy|compliance|regulation|court|lawyer)"; then
        if echo "$prompt_lower" | grep -q -v -E "(smart contract|blockchain|crypto|ethereum)"; then
            legal_score=$((legal_score + 10))
        fi
    fi
    
    # Frontend - specific to frontend development
    if echo "$prompt_lower" | grep -q -E "(frontend|front-end|client-side|spa|single page|webpack|vite|npm|yarn)"; then
        frontend_score=$((frontend_score + 10))
    fi
    
    # Context-based adjustments
    if echo "$prompt_lower" | grep -q -E "responsive"; then
        web_score=$((web_score + 5))
        mobile_score=$((mobile_score + 3))
    fi
    
    # File system context detection
    if [ -f "$current_dir/package.json" ]; then
        if grep -qi "react\|vue\|angular" "$current_dir/package.json" 2>/dev/null; then
            web_score=$((web_score + 5))
            frontend_score=$((frontend_score + 3))
        elif grep -qi "express\|fastify\|koa\|nest" "$current_dir/package.json" 2>/dev/null; then
            backend_score=$((backend_score + 5))
        fi
    elif [ -f "$current_dir/requirements.txt" ] || [ -f "$current_dir/setup.py" ]; then
        backend_score=$((backend_score + 3))
    elif [ -f "$current_dir/Cargo.toml" ]; then
        backend_score=$((backend_score + 3))
    elif [ -f "$current_dir/go.mod" ]; then
        backend_score=$((backend_score + 3))
    elif [ -f "$current_dir/pubspec.yaml" ]; then
        mobile_score=$((mobile_score + 5))
    elif [ -f "$current_dir/unity.exe" ] || [ -d "$current_dir/Assets" ]; then
        gaming_score=$((gaming_score + 5))
    fi
    
    # Find the domain with highest score
    local max_score=0
    local best_domain="general"
    
    # Check each domain score
    if [ $sql_score -gt $max_score ]; then
        max_score=$sql_score
        best_domain="sql"
    fi
    if [ $web_score -gt $max_score ]; then
        max_score=$web_score
        best_domain="web"
    fi
    if [ $mobile_score -gt $max_score ]; then
        max_score=$mobile_score
        best_domain="mobile"
    fi
    if [ $backend_score -gt $max_score ]; then
        max_score=$backend_score
        best_domain="backend"
    fi
    if [ $frontend_score -gt $max_score ]; then
        max_score=$frontend_score
        best_domain="frontend"
    fi
    if [ $ai_score -gt $max_score ]; then
        max_score=$ai_score
        best_domain="ai"
    fi
    if [ $gaming_score -gt $max_score ]; then
        max_score=$gaming_score
        best_domain="gaming"
    fi
    if [ $crypto_score -gt $max_score ]; then
        max_score=$crypto_score
        best_domain="crypto"
    fi
    if [ $devops_score -gt $max_score ]; then
        max_score=$devops_score
        best_domain="devops"
    fi
    if [ $saas_score -gt $max_score ]; then
        max_score=$saas_score
        best_domain="saas"
    fi
    if [ $branding_score -gt $max_score ]; then
        max_score=$branding_score
        best_domain="branding"
    fi
    if [ $cine_score -gt $max_score ]; then
        max_score=$cine_score
        best_domain="cine"
    fi
    if [ $education_score -gt $max_score ]; then
        max_score=$education_score
        best_domain="education"
    fi
    if [ $healthcare_score -gt $max_score ]; then
        max_score=$healthcare_score
        best_domain="healthcare"
    fi
    if [ $finance_score -gt $max_score ]; then
        max_score=$finance_score
        best_domain="finance"
    fi
    if [ $legal_score -gt $max_score ]; then
        max_score=$legal_score
        best_domain="legal"
    fi
    
    # If no clear winner (score < 6), default to general or use secondary logic
    if [ $max_score -lt 6 ]; then
        # Secondary logic for common patterns that might be missed
        if echo "$prompt_lower" | grep -q -E "(web|site|page)"; then
            best_domain="web"
        elif echo "$prompt_lower" | grep -q -E "(server|backend|api)"; then
            best_domain="backend"
        elif echo "$prompt_lower" | grep -q -E "(app)" && echo "$prompt_lower" | grep -q -v -E "(web|site)"; then
            best_domain="mobile"
        else
            best_domain="general"
        fi
    fi
    
    echo "$best_domain"
}

# Funci√≥n para generar nombre de template autom√°tico INTELIGENTE
generate_template_name() {
    local prompt="$1"
    local domain="$2"

    # Limpiar prompt removiendo palabras de relleno
    local cleaned_prompt=$(echo "$prompt" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-zA-Z0-9 ]//g')
    
    # Remover palabras de relleno en espa√±ol
    cleaned_prompt=$(echo "$cleaned_prompt" | sed -E 's/\b(bueno|pues|entonces|vamos|venga|oye|mira|ok|vale|hagamos|por|favor|que|de|la|el|en|con|para|un|una|del|las|los)\b//g')
    
    # Mapear frases comunes a nombres universales
    if echo "$cleaned_prompt" | grep -q "git.*commit\|commit.*push\|push.*commit"; then
        echo "${domain}_git_commit_push_workflow"
        return
    elif echo "$cleaned_prompt" | grep -q "revisa.*antes.*cerrar\|review.*before.*clos"; then
        echo "${domain}_sprint_closure_review"
        return  
    elif echo "$cleaned_prompt" | grep -q "hexagon.*chart"; then
        echo "${domain}_hexagon_chart_component"
        return
    elif echo "$cleaned_prompt" | grep -q "create.*login\|login.*form"; then
        echo "${domain}_login_form_component"
        return
    elif echo "$cleaned_prompt" | grep -q "dashboard"; then
        echo "${domain}_dashboard_component"
        return
    fi
    
    # Extraer palabras clave t√©cnicas (solo palabras >3 caracteres, m√°ximo 3)
    local keywords=$(echo "$cleaned_prompt" | awk '{for(i=1;i<=NF;i++) if(length($i)>3) print $i}' | head -3 | tr '\n' '_')
    keywords=${keywords%_}  # Remover √∫ltimo underscore
    
    # Si no hay keywords suficientes, usar t√©rminos por defecto
    if [ -z "$keywords" ] || [ ${#keywords} -lt 4 ]; then
        keywords="feature_implementation"
    fi

    # Generar nombre sin timestamp para reusabilidad
    local template_name="${domain}_${keywords}"

    echo "$template_name"
}

# Verificar si se pidi√≥ ayuda o comandos especiales
if [[ "$1" == "-h" || "$1" == "--help" || "$1" == "help" ]]; then
    show_help
    exit 0
fi

# Comando de verificaci√≥n
if [[ "$1" == "--verify" ]]; then
    echo -e "${CYAN}üîç pimpprompt: Verificaci√≥n del Sistema${NC}"
    echo ""
    
    # Check global installation
    if command -v pimpprompt >/dev/null 2>&1; then
        echo -e "${GREEN}‚úÖ Comando global instalado correctamente${NC}"
        echo "   Ubicaci√≥n: $(which pimpprompt)"
    else
        echo -e "${RED}‚ùå Comando global no encontrado${NC}"
        exit 1
    fi
    
    # Check current directory context
    echo ""
    echo -e "${YELLOW}üìÅ Contexto del Proyecto Actual:${NC}"
    echo "   Directorio: $(pwd)"
    
    # Detect project context
    if [[ -f "package.json" ]]; then
        PROJECT_NAME=$(node -p "require('./package.json').name" 2>/dev/null || echo "unknown")
        echo "   Proyecto: $PROJECT_NAME"
        
        # Check for framework
        if [[ -f "next.config.js" ]] || grep -q '"next"' package.json 2>/dev/null; then
            echo -e "${GREEN}   Framework: Next.js detectado${NC}"
        fi
        
        # Check for Supabase
        if grep -q '"@supabase/supabase-js"' package.json 2>/dev/null; then
            echo -e "${GREEN}   Backend: Supabase detectado${NC}"
        fi
        
        # Check for React
        if grep -q '"react"' package.json 2>/dev/null; then
            echo -e "${GREEN}   Frontend: React detectado${NC}"
        fi
    else
        echo "   Sin package.json - proyecto no JavaScript/Node"
    fi
    
    # Test basic functionality
    echo ""
    echo -e "${YELLOW}üß™ Prueba de Funcionalidad:${NC}"
    if pimpprompt --help >/dev/null 2>&1; then
        echo -e "${GREEN}‚úÖ Help command funciona${NC}"
    else
        echo -e "${RED}‚ùå Help command falla${NC}"
    fi
    
    echo ""
    echo -e "${GREEN}üéâ Verificaci√≥n completada - pimpprompt est√° listo para usar${NC}"
    echo -e "${PURPLE}üí° Usa: pimpprompt \"tu prompt aqu√≠\" para procesar prompts${NC}"
    exit 0
fi

# Manejar modo --max para prompts ultra-detallados  
if [[ "$1" == "--max" ]]; then
    if [ -z "$2" ]; then
        echo -e "${RED}‚ùå Error: Debes proporcionar un prompt para el modo MAX${NC}"
        echo "Uso: pimpprompt --max \"tu prompt aqu√≠\""
        exit 1
    fi
    
    echo -e "${BLUE}${BOLD}üöÄ pimpprompt: Modo MAX - Prompts Ultra-Detallados${NC}"
    echo -e "${CYAN}üìù Prompt:${NC} $2"
    echo -e "${PURPLE}‚ö° Modo MAX activado: Generando prompt m√°ximo de 2000+ palabras${NC}"
    echo ""
    
    # Detecci√≥n autom√°tica de contexto
    echo -e "${YELLOW}üß† Paso 1: Detectando contexto autom√°ticamente...${NC}"
    DOMAIN=$(detect_domain "$2")
    echo -e "${GREEN}   ‚úÖ Dominio detectado:${NC} $DOMAIN"
    
    # Generar nombre de template autom√°tico
    TEMPLATE_NAME=$(generate_template_name "$2" "$DOMAIN")
    echo -e "${GREEN}   üíæ Template generado:${NC} ${TEMPLATE_NAME}_MAX"
    echo ""
    
    # Resolver el path real del script
    if [[ -L "$0" ]]; then
        REAL_PATH="$(readlink -f "$0" 2>/dev/null || readlink "$0")"
        SCRIPT_DIR="$(cd "$(dirname "$REAL_PATH")" && pwd)"
    else
        SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
    fi
    cd "$SCRIPT_DIR"
    
    # Ejecutar con modo MAX
    node "$SCRIPT_DIR/process-prompt.cjs" "$2" "$DOMAIN" "${TEMPLATE_NAME}_MAX" "MAX"
    exit 0
fi

# Manejar comandos de b√∫squeda
if [[ "$1" == "--search" ]]; then
    if [ -z "$2" ]; then
        echo -e "${RED}‚ùå Error: Debes proporcionar una palabra clave para buscar${NC}"
        echo "Uso: pimpprompt --search \"keyword\""
        exit 1
    fi
    
    echo -e "${BLUE}${BOLD}üîç Buscando templates: ${NC}$2"
    echo ""
    
    # Resolver correctamente el path del script (mismo patr√≥n que el principal)
    if [[ -L "$0" ]]; then
        REAL_PATH="$(readlink -f "$0" 2>/dev/null || readlink "$0")"
        SCRIPT_DIR="$(cd "$(dirname "$REAL_PATH")" && pwd)"
    else
        SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
    fi
    cd "$SCRIPT_DIR"
    
    node -e "
    const DirectProcessor = require('./direct-processor.cjs');
    const ps = new DirectProcessor();
    
    ps.searchPrompts('$2', null, 10).then(results => {
        if (results.length === 0) {
            console.log('   üíî No se encontraron templates con \"$2\"');
            console.log('   üí° Intenta con otras palabras clave o crea uno nuevo');
        } else {
            console.log(\`   ‚úÖ Encontrados \${results.length} templates:\`);
            console.log('');
            results.forEach((template, index) => {
                console.log(\`   \${index + 1}. \${template.name}\`);
                console.log(\`      Dominio: \${template.domain}\`);
                console.log(\`      Calidad: \${Math.round((template.score?.overall || 0) * 100)}%\`);
                console.log(\`      Descripci√≥n: \${template.description || 'N/A'}\`);
                console.log('');
            });
        }
    }).catch(err => {
        console.log('   ‚ö†Ô∏è  Error en b√∫squeda:', err.message);
    });
    "
    exit 0
fi

if [[ "$1" == "--list" ]]; then
    DOMAIN_FILTER="$2"
    
    echo -e "${BLUE}${BOLD}üìã Templates disponibles${NC}"
    if [ ! -z "$DOMAIN_FILTER" ]; then
        echo -e "${CYAN}   Filtro de dominio: ${NC}$DOMAIN_FILTER"
    fi
    echo ""
    
    # Resolver correctamente el path del script (mismo patr√≥n que el principal)
    if [[ -L "$0" ]]; then
        REAL_PATH="$(readlink -f "$0" 2>/dev/null || readlink "$0")"
        SCRIPT_DIR="$(cd "$(dirname "$REAL_PATH")" && pwd)"
    else
        SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
    fi
    cd "$SCRIPT_DIR"
    
    node -e "
    const DirectProcessor = require('./direct-processor.cjs');
    const ps = new DirectProcessor();
    
    ps.searchPrompts('', '$DOMAIN_FILTER', 20).then(results => {
        if (results.length === 0) {
            console.log('   üíî No hay templates disponibles');
            if ('$DOMAIN_FILTER') {
                console.log('   üí° Intenta sin filtro de dominio: pimpprompt --list');
            }
        } else {
            console.log(\`   ‚úÖ \${results.length} templates encontrados:\`);
            console.log('');
            results.forEach((template, index) => {
                console.log(\`   \${index + 1}. \${template.name}\`);
                console.log(\`      Dominio: \${template.domain}\`);
                console.log(\`      ID: \${template.id}\`);
                console.log(\`      Calidad: \${Math.round((template.score?.overall || 0) * 100)}%\`);
                console.log('');
            });
        }
        
        ps.getStats().then(stats => {
            console.log('   üìä Estad√≠sticas globales:');
            console.log(\`      Total templates: \${stats.totalPrompts}\`);
            console.log(\`      Calidad promedio: \${Math.round(stats.averageScore * 100)}%\`);
            console.log(\`      Dominios activos: \${stats.domainsUsed.join(', ')}\`);
        }).catch(err => console.log('   üìä Estad√≠sticas no disponibles'));
    }).catch(err => {
        console.log('   ‚ö†Ô∏è  Error al listar templates:', err.message);
    });
    "
    exit 0
fi

# Verificar que se proporcion√≥ un prompt
if [ -z "$1" ]; then
    echo -e "${RED}‚ùå Error: Necesitas proporcionar un prompt${NC}"
    echo ""
    show_help
    exit 1
fi

# Solo se acepta el prompt, todo lo dem√°s es autom√°tico
PROMPT="$1"

# Iniciar escalera de proceso inteligente
echo -e "${BLUE}${BOLD}üöÄ pimpprompt: Escalera de Proceso Inteligente${NC}"
echo -e "${CYAN}üìù Prompt:${NC} $PROMPT"
echo ""

# Paso 1: Detecci√≥n autom√°tica de contexto (MEJORADA)
echo -e "${YELLOW}üß† Paso 1: Detectando contexto autom√°ticamente...${NC}"
DOMAIN=$(detect_domain "$PROMPT")
echo -e "${GREEN}   ‚úÖ Dominio detectado:${NC} $DOMAIN"

# Paso 2: Generar nombre de template autom√°tico
TEMPLATE_NAME=$(generate_template_name "$PROMPT" "$DOMAIN")
echo -e "${GREEN}   üíæ Template generado:${NC} $TEMPLATE_NAME"
echo ""

# Ejecutar PromptSmith - Resolver el path real del script
if [[ -L "$0" ]]; then
    # Si es un symlink, obtener el path real correctamente
    REAL_PATH="$(readlink -f "$0" 2>/dev/null || readlink "$0")"
    SCRIPT_DIR="$(cd "$(dirname "$REAL_PATH")" && pwd)"
else
    # Si no es un symlink, obtener el path normal
    SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
fi
cd "$SCRIPT_DIR"

# Escalera completa de procesamiento inteligente
node "$SCRIPT_DIR/process-prompt.cjs" "$PROMPT" "$DOMAIN" "$TEMPLATE_NAME"